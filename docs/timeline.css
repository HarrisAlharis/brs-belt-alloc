:root{
  --bg:#0d151d;
  --panel:#111b26;
  --grid:#1b2a39;
  --grid-faint:#14212f;
  --text:#dce6f2;
  --text-dim:#93a4b7;
  --accent:#48a3ff;

  --puck-radius:14px;
  --puck-pad-x:14px;
  --puck-pad-y:10px;

  /* vertical packing */
  --lane-height:58px;
  --lane-gap:10px;
  --belt-pad-y:18px;
}

*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  background:var(--bg);
  color:var(--text);
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
  font-family:ui-sans-serif,system-ui,"Segoe UI",Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
}

/* Top bar and controls */
.topbar{
  display:flex;align-items:center;justify-content:space-between;
  padding:12px 16px;
  position:sticky;top:0;z-index:60;
  background:linear-gradient(180deg,#0d151d,#0d151d 60%,transparent);
  border-bottom:1px solid #12203020;
}
.topbar .brand{font-weight:700;letter-spacing:.2px}
.topbar .meta{color:var(--text-dim);font-size:14px}

.controls{
  display:flex;align-items:center;justify-content:space-between;
  gap:12px;padding:8px 12px 10px;
  position:sticky;top:44px;z-index:55;
  background:linear-gradient(180deg,#0d151d,#0d151d 60%,transparent);
  border-bottom:1px solid #12203040;
}
.chiprow{display:flex;flex-wrap:wrap;gap:8px}
.chip{
  background:#162332;border:1px solid #22374d;color:var(--text);
  border-radius:999px;padding:6px 12px;font-size:14px;cursor:pointer
}
.chip.on{background:#1c2a3c;border-color:#2b4b6a}

.right-controls{display:flex;align-items:center;gap:10px}
.lbl{color:var(--text-dim);font-size:14px}
#zoom{
  appearance:none;background:#162332;color:var(--text);border:1px solid #22374d;
  border-radius:10px;padding:8px 12px
}
.btn{background:#162332;border:1px solid #22374d;color:var(--text);
  border-radius:10px;padding:8px 12px;cursor:pointer}
.legend{display:flex;align-items:center;gap:14px;color:var(--text-dim);font-size:14px}
.dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;vertical-align:-1px}
.dot-ok{background:#1d5f3f}
.dot-10{background:#6d5a13}
.dot-20{background:#6a2020}
.dot-early{background:#1b4864}
.dot-stale{background:#3a3f4a}

/* Viewport with sticky belt labels */
.viewport{display:grid;grid-template-columns:130px 1fr}

.belts-col{
  position:sticky;left:0;top:96px;align-self:start;z-index:10;
  background:linear-gradient(180deg,#0d151d,#0d151d);
  border-right:1px solid #12203040;
  min-height:calc(100vh - 96px);
  padding-top:0;
}
.belts-col .belt-name{
  height:calc(var(--belt-pad-y)*2 + var(--lane-height));
  display:flex;align-items:center;justify-content:flex-start;
  padding-left:16px;color:var(--text-dim);font-weight:600;
  border-bottom:1px dashed var(--grid-faint);
}

/* Scrollable content */
.scroll-outer{
  position:relative;overflow:auto;border-left:1px solid #12203060;
  height:calc(100vh - 96px);
}
.scroll-inner{position:relative;min-width:100%}

/* Top hour ruler (canvas) */
.ruler{
  position:sticky;top:96px;left:0;right:0;z-index:40;
  height:44px;background:var(--panel);
  border-bottom:1px solid #1a2a3a;
  display:block;
}

/* Rows grid (pucks live inside) */
.rows{position:relative;background:linear-gradient(180deg,var(--bg),var(--bg))}
.belt-row{
  position:relative;padding:var(--belt-pad-y) 10px;border-bottom:1px dashed var(--grid-faint)
}
.belt-row .row-inner{position:relative;margin-left:0}

/* vertical hour grid lines */
.gridline{
  position:absolute;top:0;bottom:0;width:1px;background:var(--grid);
  transform:translateX(-.5px)
}

/* Now line */
.now-line{
  position:absolute;top:0;bottom:0;width:2px;
  background:rgba(72,163,255,.85);
  box-shadow:0 0 12px rgba(72,163,255,.6),0 0 2px rgba(72,163,255,.9)
}

/* Pucks */
.puck{
  position:absolute;height:var(--lane-height);min-width:120px;
  border-radius:var(--puck-radius);
  padding:var(--puck-pad-y) var(--puck-pad-x);
  display:flex;align-items:center;gap:10px;
  box-shadow:0 12px 24px rgba(0,0,0,.25), inset 0 0 0 1px rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.06);
  color:#f2f5f9;cursor:default;overflow:hidden
}
.puck .title{font-weight:700;letter-spacing:.3px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.puck .sub{font-size:12px;color:var(--text-dim);margin-left:auto;white-space:nowrap}

/* delay classes (match your legend colours) */
.puck.ok{background:#103a2a}
.puck.mid{background:#254118}
.puck.late{background:#4a1818}
.puck.early{background:#12344a}

/* Tooltip */
.puck[data-tip]:hover:after{
  content:attr(data-tip);
  position:absolute;left:50%;bottom:calc(100% + 10px);transform:translateX(-50%);
  white-space:pre;font-size:13px;line-height:1.35;
  background:#0f2234;color:var(--text);
  border:1px solid #23425f;border-radius:8px;padding:10px 12px;z-index:30;
  max-width:420px;box-shadow:0 10px 20px rgba(0,0,0,.4)
}

/* Footer */
.foot{padding:10px 12px;color:var(--text-dim);font-size:14px;border-top:1px solid #12203040}
PerMin;

  function packLanes(items) {
    // Sort by start time
    const sorted = items.slice().sort((a,b)=>+new Date(a.start) - +new Date(b.start));
    const lanesLastEnd = []; // ms
    for (const f of sorted) {
      const s = +new Date(f.start), e = +new Date(f.end);
      let lane = -1;
      for (let i=0; i<lanesLastEnd.length; i++) {
        if (s >= (lanesLastEnd[i] + MIN_SEPARATION_MS)) { lane = i; break; }
      }
      if (lane === -1) { lane = lanesLastEnd.length; lanesLastEnd.push(e); }
      else { lanesLastEnd[lane] = e; }
      f._lane = lane;
    }
    return { lanes: Math.max(1, lanesLastEnd.length), items: sorted };
  }

  // ------- draw -------
  function drawRuler() {
    if (!canvasRuler) return;
    const ctx = canvasRuler.getContext('2d');
    const width = Math.max(xForDate(timeMax) + 200, scrollOuter.clientWidth);
    const height = 44;

    // crisp canvas
    const dpr = window.devicePixelRatio || 1;
    canvasRuler.width  = Math.floor(width  * dpr);
    canvasRuler.height = Math.floor(height * dpr);
    canvasRuler.style.width  = `${width}px`;
    canvasRuler.style.height = `${height}px`;
    ctx.setTransform(dpr,0,0,dpr,0,0);

    ctx.clearRect(0,0,width,height);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--panel') || '#111b26';
    ctx.fillRect(0,0,width,height);

    ctx.strokeStyle = '#1a2a3a';
    ctx.beginPath(); ctx.moveTo(0,height-1); ctx.lineTo(width,height-1); ctx.stroke();

    ctx.fillStyle = '#dce6f2';
    ctx.font = '14px ui-sans-serif, system-ui, Segoe UI, Roboto, Arial';
    ctx.textBaseline = 'alphabetic';

    // hour ticks
    const start = new Date(timeMin); start.setMinutes(0,0,0);
    for (let t = +start; t <= +timeMax; t += 60*minute) {
      const x = Math.floor(xForDate(t));
      // tick
      ctx.fillStyle = '#213043';
      ctx.fillRect(x, 0, 1, height);
      // label
      ctx.fillStyle = '#dce6f2';
      ctx.fillText(dFmt(t), x + 8, height - 12);
    }
  }

  function buildPuck(f) {
    const p = el('div', `puck ${classByDelay(f.delay_min)}`);
    const title = el('div','title'); title.textContent = `${(f.flight||'').trim()} • ${(f.origin_iata||'').trim() || f.origin || ''}`.replace(/\s+/g,' ');
    const sub    = el('div','sub');   sub.textContent   = `${dFmt(f.start)} → ${dFmt(f.end)}`;

    const tipLines = [
      `${(f.flight||'').trim()} ${f.origin ? `• ${f.origin}` : ''}`,
      `${dFmt(f.start)} → ${dFmt(f.end)}`,
      f.flow, f.airline, f.aircraft,
      f.reason ? `Reason: ${f.reason}` : ''
    ].filter(Boolean);
    p.setAttribute('data-tip', tipLines.join('\n'));

    p.appendChild(title); p.appendChild(sub);

    // position
    const left = xForDate(f.start);
    const right = xForDate(f.end);
    p.style.left  = `${left}px`;
    p.style.width = `${Math.max(120, right - left - 4)}px`;
    p.style.top   = `${f._lane * (LANE_H + LANE_GAP)}px`;

    return p;
  }

  function classByDelay(d) {
    if (d == null) return 'ok';
    if (d >= 20) return 'late';
    if (d >= 10) return 'mid';
    if (d <= -1)  return 'early';
    return 'ok';
  }

  function drawRows() {
    rowsHost.innerHTML = '';
    const frag = document.createDocumentFragment();

    let totalHeight = 0;
    const beltsToShow = BELTS_ORDER.filter(b => beltFilter.size === 0 || beltFilter.has(b));

    // per belt
    for (const b of beltsToShow) {
      const beltRow = el('div','belt-row');
      const beltName = el('div','belt-name'); beltName.textContent = `Belt ${b}`;
      const inner = el('div','row-inner');

      beltRow.appendChild(beltName);
      beltRow.appendChild(inner);

      const items = flights.filter(r => r.belt === b);
      const { lanes, items: packed } = packLanes(items);

      const contentH = lanes * (LANE_H + LANE_GAP) - LANE_GAP; // last lane no gap
      beltRow.style.minHeight = `calc(${BELT_PAD}px * 2 + ${contentH}px)`;

      for (const f of packed) inner.appendChild(buildPuck(f));

      frag.appendChild(beltRow);
      // add height after measuring
      totalHeight += beltRow.getBoundingClientRect().height;
    }

    rowsHost.appendChild(frag);

    // resize scroll area width to fit timeline
    const width = Math.max(xForDate(timeMax) + 200, scrollOuter.clientWidth);
    scrollInner.style.width = `${width}px`;

    // vertical hour gridlines (behind rows)
    addGridlines(totalHeight);

    // position/update Now line
    updateNowLine(totalHeight);
  }

  function addGridlines(totalHeight) {
    // remove previous
    [...scrollInner.querySelectorAll('.gridline')].forEach(x => x.remove());
    const start = new Date(timeMin); start.setMinutes(0,0,0);
    const frag = document.createDocumentFragment();
    for (let t = +start; t <= +timeMax; t += 60*minute) {
      const x = xForDate(t);
      const g = el('div','gridline');
      g.style.left = `${x}px`;
      g.style.height = `${totalHeight}px`;
      frag.appendChild(g);
    }
    scrollInner.appendChild(frag);
  }

  function updateNowLine(totalHeight) {
    if (!nowLine) return;
    nowLine.style.left = `${xForDate(Date.now())}px`;
    nowLine.style.height = `${totalHeight}px`;
  }

  function drawAll() {
    drawRuler();
    drawRows();
  }

  // ------- interactions -------
  zoomSel?.addEventListener('change', () => { pxPerMin = parseFloat(zoomSel.value || '6'); drawAll(); });
  nowBtn?.addEventListener('click', () => {
    const nowX = xForDate(Date.now());
    const viewW = scrollOuter.clientWidth;
    scrollOuter.scrollLeft = Math.max(0, nowX - viewW/2);
  });

  // keep ruler aligned with content
  scrollOuter.addEventListener('scroll', () => {
    // ruler is a canvas spanning the same scrollable width, so no translate needed,
    // we only keep the "Now" line visually in place.
    // (If you later pin the canvas, you can sync translateX here.)
  });
  window.addEventListener('resize', drawAll);
  // small timer to keep the "Now" line creeping without full redraw
  setInterval(() => updateNowLine(rowsHost.getBoundingClientRect().height || 0), 30 * 1000);

  // ------- live refresh every ~90s (as before) -------
  setInterval(() => {
    fetch('assignments.json', { cache: 'no-store' })
      .then(r => r.json())
      .then(data => {
        if (!data) return;
        const prev = assignments?.generated_at_utc;
        assignments = data;
        flights = (data.rows || []).slice();
        if (data.generated_at_utc !== prev) {
          load();     // window may shift
        } else {
          drawAll();  // same window, just redraw
        }
      }).catch(()=>{});
  }, 90 * 1000);

  // ------- boot -------
  load().then(() => {
    // center near now on first paint
    const nowX = xForDate(Date.now());
    const viewW = scrollOuter.clientWidth;
    scrollOuter.scrollLeft = Math.max(0, nowX - viewW/2);
  });
})();
