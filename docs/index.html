<script>
// === FILTER + SORT (DROP-IN) ===============================================

// Filter state (defaults ON)
const FILTERS = { early: true, estimated: true, delayed: true, scheduled: true };

// Find any existing chip by common ids we used before
function chip(...ids){ for (const id of ids){ const el=document.getElementById(id); if (el) return el; } return null; }

// Attach listeners to the four chips (support old/new ids)
(function initChips(){
  const bindings = [
    ['early',     ['filter-early','chip-early']],
    ['estimated', ['filter-estimated','chip-estimated','filter-ontime']],
    ['delayed',   ['filter-delayed','chip-delayed']],
    ['scheduled', ['filter-scheduled','chip-scheduled']]
  ];
  bindings.forEach(([key, ids])=>{
    const el = chip(...ids);
    if (!el) return;
    el.addEventListener('click', ()=>{
      FILTERS[key] = !FILTERS[key];
      el.classList.toggle('chip-off', !FILTERS[key]); // respect existing styles
      render(); // re-render with new filters
    });
  });
})();

// Classify a row for filtering (uses delay_min/status already in JSON)
function rowCategory(r){
  const s = (r.status || '').toLowerCase();
  if (s.startsWith('scheduled') || r.eta == null) return 'scheduled';
  if (s.startsWith('estimated') || s.startsWith('finals')) {
    // use delay_min if present: negative = early, |delay|<=5 treated as on-time under "estimated"
    const d = typeof r.delay_min === 'number' ? r.delay_min : null;
    if (d !== null && d <= -5) return 'early';
    if (d !== null && d > 5)   return 'delayed';
    return 'estimated'; // on-time window or unknown small variance
  }
  if (s.startsWith('delayed')) return 'delayed';
  // Landed rows are not part of the three timing buckets; let them follow ETA sorting
  return 'estimated';
}

function passesFilters(r){
  const cat = rowCategory(r);
  if (cat === 'early')     return FILTERS.early;
  if (cat === 'delayed')   return FILTERS.delayed;
  if (cat === 'scheduled') return FILTERS.scheduled;
  return FILTERS.estimated; // 'estimated' bucket (incl. on-time)
}

// Sort so the closest **upcoming** ETA is first, then the rest.
// ETA is ISO in r.eta; scheduled-only items (no ETA) go after upcoming; past ETA at the end.
function sortRowsByProximity(rows){
  const now = Date.now();

  const toEpoch = r => {
    if (r.eta) {
      const t = Date.parse(r.eta);
      if (!Number.isNaN(t)) return t;
    }
    return NaN; // scheduled-only or unparsable ETA
  };

  const upcoming = [];
  const scheduledOnly = [];
  const past = [];

  for (const r of rows){
    const t = toEpoch(r);
    if (Number.isNaN(t)) { scheduledOnly.push(r); continue; }
    if (t >= now) upcoming.push({t, r});
    else past.push({t, r});
  }

  upcoming.sort((a,b)=> a.t - b.t); // nearest future first
  // keep scheduled-only in given order (or sort by scheduled_local if you prefer)
  past.sort((a,b)=> a.t - b.t);     // oldest past first (they’ll be at the bottom)

  return [
    ...upcoming.map(x=>x.r),
    ...scheduledOnly,
    ...past.map(x=>x.r),
  ];
}

// Render hook: filter → sort → paint
function render(){
  if (!window.__ALL_ROWS__) return;             // assumes your fetch populated __ALL_ROWS__
  const filtered = window.__ALL_ROWS__.filter(passesFilters);
  const ordered  = sortRowsByProximity(filtered);
  paintTable(ordered);                           // call your existing row painter
}

// If your data loader used another variable, mirror it here after load.
// Example (keep this adapter right after you finish loading JSON):
// window.__ALL_ROWS__ = data.rows; render();

// === END FILTER + SORT ======================================================
</script>
