    (async function () {
      const meta = document.querySelector('#meta');
      const tbody = document.querySelector('#tbody');

      // try a couple of locations – GH Pages sometimes serves from root
      const candidates = [
        'assignments.json',
        './assignments.json',
        '/brs-belt-alloc/assignments.json'
      ];

      let data = null;
      let lastError = null;

      for (const url of candidates) {
        try {
          const res = await fetch(url + '?v=' + Date.now(), { cache: 'no-store' });
          if (!res.ok) throw new Error('HTTP ' + res.status + ' on ' + url);
          const text = await res.text();
          data = JSON.parse(text);
          break;
        } catch (err) {
          lastError = err;
        }
      }

      if (!data) {
        tbody.innerHTML = `<tr><td colspan="9" class="empty error">Could not load <code>assignments.json</code> from GitHub Pages. ${lastError ? lastError.message : ''}</td></tr>`;
        meta.textContent = 'Load failed';
        return;
      }

      // ---- NEW: keep all rows, filter/sort client-side
      let ALL_ROWS = Array.isArray(data.rows) ? data.rows : [];

      // chip state: true = visible
      const filtersState = {
        early: true,        // Early >5m
        ontime: true,       // Estimated / On-time window
        delayed: true,      // Delayed >5m
        scheduled: true     // Scheduled only (no ETA yet)
      };

      // work out which bucket a row belongs to
      function categoryOf(r){
        const statusLower = String(r.status || '').toLowerCase();
        const hasEta = !!(r.eta_local && r.eta_local.trim());

        // "scheduled only" = no live ETA yet / pure scheduled row
        if (!hasEta || statusLower.startsWith('scheduled')) {
          return 'scheduled';
        }

        // delay_min tells us early/on-time/delayed
        const d = (typeof r.delay_min === 'number') ? r.delay_min : null;
        if (d !== null) {
          if (d < -5) return 'early';   // more than 5 min early
          if (d > 5)  return 'delayed'; // more than 5 min late
          return 'ontime';              // within ±5 min window
        }

        // landed / estimated but no numeric delay_min -> treat as on-time bucket
        return 'ontime';
      }

      // convert row's timing into a sortable ms timestamp:
      // 1) ETA ISO
      // 2) start ISO
      // 3) scheduled_local "HH:MM" today
      function rowTimeMs(r){
        if (r.eta) {
          const d = new Date(r.eta);
          if (!isNaN(+d)) return +d;
        }
        if (r.start) {
          const d = new Date(r.start);
          if (!isNaN(+d)) return +d;
        }
        if (r.scheduled_local) {
          const m = r.scheduled_local.match(/^(\d{1,2}):(\d{2})$/);
          if (m) {
            const nowD = new Date();
            const hh = parseInt(m[1],10);
            const mm = parseInt(m[2],10);
            return +new Date(
              nowD.getFullYear(),
              nowD.getMonth(),
              nowD.getDate(),
              hh, mm, 0, 0
            );
          }
        }
        return Number.MAX_SAFE_INTEGER;
      }

      // render table for current filter state
      function renderTable(){
        const shown = ALL_ROWS.filter(r => {
          const cat = categoryOf(r);
          return !!filtersState[cat];
        });

        shown.sort((a,b) => rowTimeMs(a) - rowTimeMs(b));

        if (!shown.length) {
          tbody.innerHTML = `<tr><td colspan="9" class="empty">No arrivals match current filters.</td></tr>`;
          return;
        }

        tbody.innerHTML = shown.map(r => renderRow(r)).join('');
      }

      // hook up the chips (must already exist in the HTML with .filter-chip and data-cat="early"/"ontime"/"delayed"/"scheduled")
      document.querySelectorAll('.filter-chip').forEach(btn => {
        btn.addEventListener('click', () => {
          const cat = btn.getAttribute('data-cat');
          if (!cat) return;
          filtersState[cat] = !filtersState[cat];
          btn.classList.toggle('off', !filtersState[cat]); // relies on existing .off styling to dim inactive chip
          renderTable();
        });
      });

      // update header meta text and then draw initial table
      meta.textContent = `Generated ${data.generated_at_local || data.generated_at_utc || ''} • Horizon ${data.horizon_minutes || ''} min`;
      renderTable();
    })();
